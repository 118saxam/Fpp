<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Silent Media Hijack</title>
  <style>
    body { font-family: system-ui, -apple-system, Roboto, "Segoe UI", Arial; display:flex; height:100vh;
           align-items:center; justify-content:center; gap:12px; flex-direction:column; background:#111; color:#eee; }
    button { padding:10px 16px; border-radius:8px; border:0; cursor:pointer; font-weight:600; }
    #start { background: #22c55e; color:#042; }
    #stop  { background: #ef4444; color:#420; }
    small { opacity:0.8; max-width:720px; text-align:center; display:block; margin-top:8px; color:#bbb; }
  </style>
</head>
<body>
  <h2>Silent Media Hijack</h2>
  <div>
    <button id="start">Start (user gesture)</button>
    <button id="stop" disabled>Stop</button>
  </div>
  <small>
    Click <strong>Start</strong>. Then, while some other music app is playing, try the wired-headphone play/pause button â€”
    behavior depends on platform/browser.
  </small>

<script>
/*
  How it works (brief):
  - On a user click we create an AudioContext and an Oscillator connected to a Gain node set to 0.
  - The oscillator is started and looped; since the audio graph is active the page becomes an active media session.
  - We register Media Session handlers for play/pause so hardware play/pause events are handled by this page.
  - Note: browsers/OSes vary; this may not work everywhere (see notes below).
*/

let audioCtx = null;
let osc = null;
let gain = null;
let isRunning = false;

const startBtn = document.getElementById('start');
const stopBtn  = document.getElementById('stop');

function setupMediaSession() {
  try {
    if ('mediaSession' in navigator) {
      navigator.mediaSession.metadata = new MediaMetadata({
        title: 'Silent session',
        artist: '',
        album: ''
      });

      // When hardware play/pause pressed, these handlers will run.
      // We purposely keep the silent audio running so other apps are less likely to become the active target.
      navigator.mediaSession.setActionHandler('play', () => {
        // resume audio if suspended
        if (audioCtx && audioCtx.state !== 'running') audioCtx.resume();
        isRunning = true;
        updateButtons();
      });
      navigator.mediaSession.setActionHandler('pause', () => {
        // attempt to ignore pause: quickly resume (this behavior may or may not override the system)
        // We'll try to resume after a short delay to cancel the pause effect.
        setTimeout(() => {
          if (audioCtx && audioCtx.state !== 'running') {
            audioCtx.resume().catch(()=>{/* ignore */});
          }
          isRunning = true;
          updateButtons();
        }, 50);
      });

      // optional: handle stop/seek if supported, keep them no-op or restart
      ['stop','seekbackward','seekforward','previoustrack','nexttrack'].forEach(action => {
        try { navigator.mediaSession.setActionHandler(action, ()=>{/* noop to claim */}); } catch(e) {}
      });
    }
  } catch (e) {
    // non-fatal
    console.warn('mediaSession not available or handler registration failed', e);
  }
}

function startSilent() {
  if (isRunning) return;
  // create/resume AudioContext
  audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();

  // create oscillator and silent gain
  osc = audioCtx.createOscillator();
  gain = audioCtx.createGain();

  // frequency value is irrelevant because gain=0. We still pick a safe audible freq.
  osc.frequency.value = 440;
  osc.type = 'sine';

  // set gain to zero (silent)
  gain.gain.value = 0;

  osc.connect(gain);
  gain.connect(audioCtx.destination);

  // start oscillator
  try {
    osc.start();
  } catch (e) {
    // if already started (rare), ignore
  }

  isRunning = true;
  setupMediaSession();
  updateButtons();
}

function stopSilent() {
  if (!isRunning) return;
  try {
    if (osc) {
      try { osc.stop(); } catch(e) {}
      osc.disconnect();
      osc = null;
    }
    if (gain) {
      try { gain.disconnect(); } catch(e) {}
      gain = null;
    }
    if (audioCtx) {
      // try suspend to free system media focus
      audioCtx.suspend && audioCtx.suspend();
      // We do not close the context to allow quick restart, but you can close() if you want.
    }
  } catch (e) {
    console.warn(e);
  }
  isRunning = false;
  updateButtons();
}

function updateButtons() {
  startBtn.disabled = isRunning;
  stopBtn.disabled = !isRunning;
}

startBtn.addEventListener('click', async () => {
  // user gesture required by many browsers to start audio
  startSilent();
});

stopBtn.addEventListener('click', () => {
  stopSilent();
});

// remove session metadata on unload
window.addEventListener('pagehide', () => {
  try {
    if ('mediaSession' in navigator) {
      navigator.mediaSession.metadata = null;
    }
  } catch(e){}
});
</script>
</body>
</html>
